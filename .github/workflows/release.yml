# This workflow is inspired by the excellent release process of ripgrep.
# It creates a draft release, builds binaries for multiple targets in parallel,
# and then uploads them to the draft release.

name: Release

# Trigger the workflow on pushes to tags that look like a version number.
on:
  push:
    tags:
      - "[0-9]+.[0-9]+.[0-9]+"

# This permission is needed for the `gh release` commands.
permissions:
  contents: write

# Set the binary name for easy reuse.
env:
  BINARY_NAME: wp-mini-epub-cli

jobs:
  # =================================================================
  # == 1. Create a draft GitHub Release                            ==
  # =================================================================
  # This job creates a single draft release. It also validates that the
  # git tag matches the version in Cargo.toml.
  create-release:
    name: create-release
    runs-on: ubuntu-latest
    outputs:
      # Pass the determined version to other jobs.
      version: ${{ env.VERSION }}
    steps:
      - uses: actions/checkout@v4

      - name: Get the release version from the tag
        run: echo "VERSION=${{ github.ref_name }}" >> $GITHUB_ENV

      - name: Check that tag version and Cargo.toml version are the same
        shell: bash
        run: |
          # Fails if the version in Cargo.toml is not "version = "x.y.z""
          if ! grep -q "version = \"$VERSION\"" Cargo.toml; then
            echo "Error: The git tag '$VERSION' does not match the version in Cargo.toml." >&2
            exit 1
          fi
          echo "Validated that git tag and Cargo.toml version are both $VERSION."

      - name: Create GitHub Release
        env:
          # The GITHUB_TOKEN is automatically provided by GitHub Actions.
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: >
          gh release create ${{ env.VERSION }}
          --draft
          --verify-tag
          --title "v${{ env.VERSION }}"

  # =================================================================
  # == 2. Build binaries for each target and upload to the release ==
  # =================================================================
  build-release:
    name: build-release
    # This job must wait for the release to be created first.
    needs: ['create-release']
    # Use a matrix to build for multiple targets in parallel.
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        include:
          # Linux (x86_64, musl for high compatibility)
          - os: ubuntu-latest
            target: x86_64-unknown-linux-musl
            archive_ext: .tar.gz
          # Linux (x86_64, gnu for broader library support)
          - os: ubuntu-latest
            target: x86_64-unknown-linux-gnu
            archive_ext: .tar.gz
          # Linux (ARM64, gnu)
          - os: ubuntu-latest
            target: aarch64-unknown-linux-gnu
            archive_ext: .tar.gz
          # Linux (i686, 32-bit, gnu)
          - os: ubuntu-latest
            target: i686-unknown-linux-gnu
            archive_ext: .tar.gz
          # macOS (Apple Silicon)
          - os: macos-15 # Apple Silicon Runner
            target: aarch64-apple-darwin
            archive_ext: .tar.gz
          # macOS (Intel)
          - os: macos-latest # Intel Runner
            target: x86_64-apple-darwin
            archive_ext: .tar.gz
          # Windows (x86_64)
          - os: windows-latest
            target: x86_64-pc-windows-msvc
            archive_ext: .zip
          # Windows (ARM64)
          - os: windows-latest
            target: aarch64-pc-windows-msvc
            archive_ext: .zip
          # Windows (i686, 32-bit)
          - os: windows-latest
            target: i686-pc-windows-msvc
            archive_ext: .zip

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install cross-compilation tools (Linux)
        if: runner.os == 'Linux' && matrix.target != 'x86_64-unknown-linux-musl'
        run: |
          sudo apt-get update
          sudo apt-get install -y gcc-aarch64-linux-gnu gcc-multilib

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          target: ${{ matrix.target }}

      - name: Build release binary
        run: cargo build --verbose --release --target ${{ matrix.target }}

      - name: Prepare binary for packaging
        shell: bash
        run: |
          # Determine the binary path and name based on the OS.
          src_dir="target/${{ matrix.target }}/release"
          if [[ "${{ matrix.os }}" == "windows-latest" ]]; then
            mv "$src_dir/${{ env.BINARY_NAME }}.exe" "$src_dir/${{ env.BINARY_NAME }}"
          fi
          echo "BINARY_PATH=$src_dir/${{ env.BINARY_NAME }}" >> $GITHUB_ENV

      - name: Prepare archive contents
        shell: bash
        run: |
          # This is where we create the directory that will be archived.
          # The version is passed from the `create-release` job.
          version="${{ needs.create-release.outputs.version }}"
          staging_dir="${{ env.BINARY_NAME }}-$version-${{ matrix.target }}"
          mkdir -p "$staging_dir"

          # Copy the binary and other important files into the staging directory.
          cp "${{ env.BINARY_PATH }}" "$staging_dir/"
          cp README.md LICENSE "$staging_dir/"

          echo "STAGING_DIR=$staging_dir" >> $GITHUB_ENV
          echo "ARCHIVE_NAME=$staging_dir${{ matrix.archive_ext }}" >> $GITHUB_ENV

      - name: Build archive
        shell: bash
        run: |
          if [[ "${{ matrix.archive_ext }}" == ".zip" ]]; then
            7z a "${{ env.ARCHIVE_NAME }}" "${{ env.STAGING_DIR }}"
          else
            tar czf "${{ env.ARCHIVE_NAME }}" "${{ env.STAGING_DIR }}"
          fi

      - name: Upload release archive
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: >
          gh release upload
          "${{ needs.create-release.outputs.version }}"
          "${{ env.ARCHIVE_NAME }}"

